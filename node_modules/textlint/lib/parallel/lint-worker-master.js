"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lintParallel = void 0;
var os_1 = __importDefault(require("os"));
var find_util_1 = require("../util/find-util");
var kernel_1 = require("@textlint/kernel");
var object_to_kernel_format_1 = require("../util/object-to-kernel-format");
var textlint_module_loader_1 = require("../engine/textlint-module-loader");
var processor_map_1 = require("../engine/processor-map");
var debug = require("debug")("textlint:parallel/lint-worker-master");
var workerPath = require.resolve("./lint-worker");
var getPluginObject = function (config) {
    var pluginMap = new processor_map_1.PluginMap();
    var moduleLoader = new textlint_module_loader_1.TextLintModuleLoader(config);
    moduleLoader.on(textlint_module_loader_1.TextLintModuleLoader.Event.plugin, function (_a) {
        var pluginName = _a[0], plugin = _a[1];
        pluginMap.set(pluginName, plugin);
    });
    // load plugin
    moduleLoader.loadFromConfig(config);
    return pluginMap.toJSON();
};
// TODO: Temporal config
var MAX_CHUNK_SIZE = 256;
exports.lintParallel = function (files, options) {
    // TODO: avoid error on Node.js 12<
    var Worker = require("worker_threads").Worker;
    var descriptor = new kernel_1.TextlintKernelDescriptor({
        rules: [],
        plugins: object_to_kernel_format_1.pluginsObjectToKernelRule(getPluginObject(options.config), options.config.pluginsConfig),
        filterRules: []
    });
    var patterns = find_util_1.pathsToGlobPatterns(files, {
        extensions: descriptor.availableExtensions
    });
    var targetFiles = find_util_1.findFiles(patterns, { ignoreFilePath: options.config.ignoreFile });
    var concurrency = options.concurrency !== undefined ? options.concurrency : os_1.default.cpus().length;
    var chunkSize = Math.min(MAX_CHUNK_SIZE, Math.ceil(targetFiles.length / concurrency));
    var promises = [];
    debug("Worker concurrency: %s, chunk size: %s, target files", concurrency, chunkSize, targetFiles.length);
    var _loop_1 = function (i) {
        promises.push(new Promise(function (resolve, reject) {
            var workerData = {
                config: options.config,
                type: options.type,
                files: targetFiles.slice(i, i + chunkSize)
            };
            var worker = new Worker(workerPath, { workerData: workerData });
            var startDate = Date.now();
            worker.on("message", function (results) {
                debug("Worker(%s) taken time: %s(ms)", worker.threadId, Date.now() - startDate);
                resolve(results);
            });
            worker.on("error", reject);
            worker.on("exit", function (exitCode) {
                if (exitCode) {
                    reject(new Error("Worker(" + worker.threadId + ") stopped with exit code " + exitCode));
                }
                else {
                    resolve();
                }
            });
        }));
    };
    for (var i = 0; i < targetFiles.length; i += chunkSize) {
        _loop_1(i);
    }
    debug("Worker count: %s", promises.length);
    return Promise.all(promises).then(function (resultsInList) {
        return resultsInList.flat();
    });
};
//# sourceMappingURL=lint-worker-master.js.map