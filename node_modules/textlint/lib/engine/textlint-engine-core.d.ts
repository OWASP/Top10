import { TextlintKernelDescriptor } from "@textlint/kernel";
import { TextLintFormatterOption } from "../textlint-interface";
import { TextLintCore } from "../textlint-core";
import { Config } from "../config/config";
import { TextlintMessage, TextlintResult } from "@textlint/kernel";
/**
 * Core of TextLintEngine.
 * It is internal user.
 *
 * Hackable adaptor
 *
 * - executeOnFiles
 * - executeOnText
 * - formatResults
 *
 * There are hackable by `executor` option.
 */
export declare abstract class AbstractTextLintEngine<LintResult extends TextlintResult> {
    private moduleLoader;
    private pluginMap;
    private ruleMap;
    private filterRuleMap;
    private executeFileBackerManger;
    private textlint;
    private config;
    /**
     * @param {TextLintCore} textlintCore
     * @returns {function()}
     */
    abstract onFile: (textlintCore: TextLintCore) => (filePath: string) => Promise<LintResult>;
    /**
     * @param {TextLintCore} textlintCore
     * @returns {function()}
     */
    abstract onText: (textlintCore: TextLintCore) => (text: string, ext?: string) => Promise<LintResult>;
    /**
     * @param {TextLintFormatterOption} formatterConfig
     */
    abstract onFormat: (formatterConfig: TextLintFormatterOption) => (results: LintResult[]) => string;
    /**
     * Process files are wanted to lint.
     * TextLintEngine is a wrapper of textlint.js.
     * Aim to be called from cli with cli options.
     * @param {Config|Object} [options] the options is command line options or Config object.
     * @constructor
     */
    constructor(options?: Config | object);
    /**
     * @deprecated remove this method
     */
    setRulesBaseDirectory(): void;
    /**
     * load plugin manually
     * Note: it high cost, please use config
     * @param {string} pluginName
     * @deprecated use Constructor(config) insteadof it
     */
    loadPlugin(pluginName: string): void;
    /**
     * load plugin manually
     * Note: it high cost, please use config
     * @param {string} presetName
     * @deprecated use Constructor(config) insteadof it
     */
    loadPreset(presetName: string): void;
    /**
     * load rule manually
     * Note: it high cost, please use config
     * @param {string} ruleName
     * @deprecated use Constructor(config) insteadof it
     */
    loadRule(ruleName: string): void;
    /**
     * load filter rule manually
     * Note: it high cost, please use config
     * @param {string} ruleName
     * @deprecated use Constructor(config) insteadof it
     */
    loadFilerRule(ruleName: string): void;
    /**
     * Update rules from current config
     * @private
     */
    private _setupRules;
    /**
     * Remove all registered rule and clear messages.
     * @private
     */
    resetRules(): void;
    /**
     * Return available extensions of plugins that include built-in plugins
     * @example
     * ```
     * engine.availableExtensions; // => [".txt", ".md"]
     * ```
     */
    get availableExtensions(): string[];
    /**
     * Return meta descriptor object for this engine
     *
     * WARNING: This is experimental getter method.
     * It will be renamed.
     */
    get textlintrcDescriptor(): TextlintKernelDescriptor;
    /**
     * Executes the current configuration on an array of file and directory names.
     * @param {String[]}  files An array of file and directory names.
     * @returns {Promise<TextlintResult[]>} The results for all files that were linted.
     */
    executeOnFiles(files: string[]): Promise<LintResult[]>;
    /**
     * If want to lint a text, use it.
     * But, if you have a target file, use {@link executeOnFiles} instead of it.
     * @param {string} text linting text content
     * @param {string} ext ext is a type for linting. default: ".txt"
     * @returns {Promise<TextlintResult[]>}
     */
    executeOnText(text: string, ext?: string): Promise<LintResult[]>;
    /**
     * format {@link results} and return output text.
     * @param {TextlintResult[]} results the collection of result
     * @returns {string} formatted output text
     * @example
     *  console.log(formatResults(results));
     */
    formatResults(results: LintResult[]): string;
    /**
     * Checks if the given message is an error message.
     * @param {TextlintMessage} message The message to check.
     * @returns {boolean} Whether or not the message is an error message.
     */
    isErrorMessage(message: TextlintMessage): boolean;
    /**
     * Checks if the given results contain error message.
     * If there is even one error then return true.
     * @param {TextlintResult[]} results Linting result collection
     * @returns {Boolean} Whether or not the results contain error message.
     */
    isErrorResults(results: TextlintResult[]): boolean;
    /**
     * @returns {boolean}
     */
    hasRuleAtLeastOne(): boolean;
}
