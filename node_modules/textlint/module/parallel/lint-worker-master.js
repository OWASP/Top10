import os from "os";
import { findFiles, pathsToGlobPatterns } from "../util/find-util";
import { TextlintKernelDescriptor } from "@textlint/kernel";
import { pluginsObjectToKernelRule } from "../util/object-to-kernel-format";
import { TextLintModuleLoader } from "../engine/textlint-module-loader";
import { PluginMap } from "../engine/processor-map";
var debug = require("debug")("textlint:parallel/lint-worker-master");
var workerPath = require.resolve("./lint-worker");
var getPluginObject = function (config) {
    var pluginMap = new PluginMap();
    var moduleLoader = new TextLintModuleLoader(config);
    moduleLoader.on(TextLintModuleLoader.Event.plugin, function (_a) {
        var pluginName = _a[0], plugin = _a[1];
        pluginMap.set(pluginName, plugin);
    });
    // load plugin
    moduleLoader.loadFromConfig(config);
    return pluginMap.toJSON();
};
// TODO: Temporal config
var MAX_CHUNK_SIZE = 256;
export var lintParallel = function (files, options) {
    // TODO: avoid error on Node.js 12<
    var Worker = require("worker_threads").Worker;
    var descriptor = new TextlintKernelDescriptor({
        rules: [],
        plugins: pluginsObjectToKernelRule(getPluginObject(options.config), options.config.pluginsConfig),
        filterRules: []
    });
    var patterns = pathsToGlobPatterns(files, {
        extensions: descriptor.availableExtensions
    });
    var targetFiles = findFiles(patterns, { ignoreFilePath: options.config.ignoreFile });
    var concurrency = options.concurrency !== undefined ? options.concurrency : os.cpus().length;
    var chunkSize = Math.min(MAX_CHUNK_SIZE, Math.ceil(targetFiles.length / concurrency));
    var promises = [];
    debug("Worker concurrency: %s, chunk size: %s, target files", concurrency, chunkSize, targetFiles.length);
    var _loop_1 = function (i) {
        promises.push(new Promise(function (resolve, reject) {
            var workerData = {
                config: options.config,
                type: options.type,
                files: targetFiles.slice(i, i + chunkSize)
            };
            var worker = new Worker(workerPath, { workerData: workerData });
            var startDate = Date.now();
            worker.on("message", function (results) {
                debug("Worker(%s) taken time: %s(ms)", worker.threadId, Date.now() - startDate);
                resolve(results);
            });
            worker.on("error", reject);
            worker.on("exit", function (exitCode) {
                if (exitCode) {
                    reject(new Error("Worker(" + worker.threadId + ") stopped with exit code " + exitCode));
                }
                else {
                    resolve();
                }
            });
        }));
    };
    for (var i = 0; i < targetFiles.length; i += chunkSize) {
        _loop_1(i);
    }
    debug("Worker count: %s", promises.length);
    return Promise.all(promises).then(function (resultsInList) {
        return resultsInList.flat();
    });
};
//# sourceMappingURL=lint-worker-master.js.map