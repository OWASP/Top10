// LICENSE : MIT
"use strict";
import { throwWithoutExperimental } from "@textlint/feature-flag";
var fs = require("fs");
var path = require("path");
var debug = require("debug")("textlint:cli");
var mkdirp = require("mkdirp");
import { options } from "./options";
import { TextLintEngine } from "./textlint-engine";
import { TextFixEngine } from "./textfix-engine";
import { Config } from "./config/config";
import { createConfigFile } from "./config/config-initializer";
import { TextLintFixer } from "./fixer/textlint-fixer";
import { Logger } from "./util/logger";
import { lintParallel } from "./parallel/lint-worker-master";
/*
 cli.js is command line **interface**

 processing role is cli-engine.js.
 @see cli-engine.js
 */
var showEmptyRuleWarning = function () {
    Logger.log("\n== No rules found, textlint hasn\u2019t done anything ==\n\nPossible reasons:\n* Your textlint config file has no rules.\n* You have no config file and you aren\u2019t passing rules via command line.\n* Your textlint config has a syntax error.\n\n=> How to set up rules?\nhttps://github.com/textlint/textlint/blob/master/docs/configuring.md\n");
};
/**
 * Print results of lining text.
 * @param {string} output the output text which is formatted by {@link TextLintEngine.formatResults}
 * @param {object} options cli option object {@lint ./options.js}
 * @returns {boolean} does print result success?
 */
function printResults(output, options) {
    if (!output) {
        return true;
    }
    var outputFile = options.outputFile;
    if (outputFile) {
        var filePath = path.resolve(process.cwd(), outputFile);
        if (fs.existsSync(filePath) && fs.statSync(filePath).isDirectory()) {
            Logger.error("Cannot write to output file path, it is a directory: %s", outputFile);
            return false;
        }
        try {
            mkdirp.sync(path.dirname(filePath));
            fs.writeFileSync(filePath, output);
        }
        catch (ex) {
            Logger.error("There was a problem writing the output file:\n%s", ex);
            return false;
        }
    }
    else {
        Logger.log(output);
    }
    return true;
}
/**
 * Encapsulates all CLI behavior for eslint. Makes it easier to test as well as
 * for other Node.js programs to effectively run the CLI.
 */
export var cli = {
    /**
     * Executes the CLI based on an array of arguments that is passed in.
     * @param {string|Array|Object} args The arguments to process.
     * @param {string} [text] The text to lint (used for TTY).
     * @returns {Promise<number>} The exit code for the operation.
     */
    execute: function (args, text) {
        var currentOptions;
        // version from package.json
        var pkgConf = require("read-pkg-up");
        var version = pkgConf.sync({ cwd: __dirname }).pkg.version;
        try {
            currentOptions = options.parse(args);
        }
        catch (error) {
            Logger.error(error.message);
            return Promise.resolve(1);
        }
        var files = currentOptions._;
        if (currentOptions.version) {
            Logger.log("v" + version);
        }
        else if (currentOptions.init) {
            return createConfigFile({
                dir: process.cwd(),
                verbose: !currentOptions.quiet
            });
        }
        else if (currentOptions.help || (!files.length && !text)) {
            Logger.log(options.generateHelp());
        }
        else {
            // specify file name of stdin content
            var stdinFilename = currentOptions.stdinFilename;
            debug("textlint --version: " + version);
            debug("Running on " + (text ? "text" : "files") + ", stdin-filename: " + stdinFilename);
            if (currentOptions.parallel) {
                debug("textlint --parallel");
                throwWithoutExperimental("--parallel is experimental feature. It should be used with --experimental flag");
                return this.executeWithParallel(currentOptions, files);
            }
            return this.executeWithOptions(currentOptions, files, text, stdinFilename);
        }
        return Promise.resolve(0);
    },
    /**
     * execute with cli options
     * @param {object} cliOptions
     * @param {string[]} files files are file path list
     * @returns {Promise<number>} exit status
     */
    executeWithParallel: function (cliOptions, files) {
        var config = Config.initWithCLIOptions(cliOptions);
        if (cliOptions.fix) {
            // --fix
            var fixEngine_1 = new TextFixEngine(config);
            if (!fixEngine_1.hasRuleAtLeastOne()) {
                showEmptyRuleWarning();
                return Promise.resolve(1);
            }
            var resultsPromise_1 = lintParallel(files, {
                type: "fix",
                config: config,
                concurrency: cliOptions.maxConcurrency
            });
            return resultsPromise_1.then(function (results) {
                debug("fix results: %j", results);
                var fixer = new TextLintFixer();
                var output = fixEngine_1.formatResults(results);
                printResults(output, cliOptions);
                // --dry-run
                if (cliOptions.dryRun) {
                    debug("Enable dry-run mode");
                    return Promise.resolve(0);
                }
                // modify file and return exit status
                return fixer.write(results).then(function () {
                    return 0;
                });
            });
        }
        // lint as default
        var lintEngine = new TextLintEngine(config);
        if (!lintEngine.hasRuleAtLeastOne()) {
            showEmptyRuleWarning();
            return Promise.resolve(1);
        }
        var resultsPromise = lintParallel(files, {
            type: "lint",
            config: config,
            concurrency: cliOptions.maxConcurrency
        });
        return resultsPromise.then(function (results) {
            debug("lint results: %j", results);
            var output = lintEngine.formatResults(results);
            if (printResults(output, cliOptions)) {
                return lintEngine.isErrorResults(results) ? 1 : 0;
            }
            else {
                return 1;
            }
        });
    },
    /**
     * execute with cli options
     * @param {object} cliOptions
     * @param {string[]} files files are file path list
     * @param {string} [text]
     * @param {string} [stdinFilename]
     * @returns {Promise<number>} exit status
     */
    executeWithOptions: function (cliOptions, files, text, stdinFilename) {
        var config = Config.initWithCLIOptions(cliOptions);
        if (cliOptions.fix) {
            // --fix
            var fixEngine_2 = new TextFixEngine(config);
            if (!fixEngine_2.hasRuleAtLeastOne()) {
                showEmptyRuleWarning();
                return Promise.resolve(1);
            }
            var resultsPromise_2 = text
                ? fixEngine_2.executeOnText(text, stdinFilename)
                : fixEngine_2.executeOnFiles(files);
            return resultsPromise_2.then(function (results) {
                debug("fix results: %j", results);
                var fixer = new TextLintFixer();
                var output = fixEngine_2.formatResults(results);
                printResults(output, cliOptions);
                // --dry-run
                if (cliOptions.dryRun) {
                    debug("Enable dry-run mode");
                    return Promise.resolve(0);
                }
                // modify file and return exit status
                return fixer.write(results).then(function () {
                    return 0;
                });
            });
        }
        // lint as default
        var lintEngine = new TextLintEngine(config);
        if (!lintEngine.hasRuleAtLeastOne()) {
            showEmptyRuleWarning();
            return Promise.resolve(1);
        }
        var resultsPromise = text ? lintEngine.executeOnText(text, stdinFilename) : lintEngine.executeOnFiles(files);
        return resultsPromise.then(function (results) {
            debug("lint results: %j", results);
            var output = lintEngine.formatResults(results);
            if (printResults(output, cliOptions)) {
                return lintEngine.isErrorResults(results) ? 1 : 0;
            }
            else {
                return 1;
            }
        });
    }
};
//# sourceMappingURL=cli.js.map