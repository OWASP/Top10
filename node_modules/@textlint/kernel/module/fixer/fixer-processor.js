// LICENSE : MIT
"use strict";
import * as assert from "assert";
import FixerTask from "../task/fixer-task";
import TaskRunner from "../task/task-runner";
import { TextlintSourceCodeImpl } from "../context/TextlintSourceCodeImpl";
import { isTxtAST } from "@textlint/ast-tester";
import _debug from "debug";
import { applyFixesToSourceCode } from "@textlint/source-code-fixer";
var debug = _debug("textlint:fixer-processor");
var FixerProcessor = /** @class */ (function () {
    /**
     * @param {Processor} processor
     * @param {MessageProcessManager} messageProcessManager
     */
    function FixerProcessor(processor, messageProcessManager) {
        this.processor = processor;
        this.messageProcessManager = messageProcessManager;
    }
    /**
     * Run fixer process
     * @param {Config} config
     * @param {string} [configBaseDir]
     * @param {TextlintKernelRule[]} [rules]
     * @param {TextlintKernelFilterRule[]} [filterRules]
     * @param {SourceCode} sourceCode
     * @returns {Promise.<TextlintFixResult>}
     */
    FixerProcessor.prototype.process = function (_a) {
        var _this = this;
        var config = _a.config, configBaseDir = _a.configBaseDir, ruleDescriptors = _a.ruleDescriptors, filterRules = _a.filterRules, sourceCode = _a.sourceCode;
        assert.ok(sourceCode);
        var _b = this.processor.processor(sourceCode.ext), preProcess = _b.preProcess, postProcess = _b.postProcess;
        // messages
        var resultFilePath = sourceCode.filePath;
        // applied fixing messages
        // Revert = Sequentially apply applied message to applied output
        // SourceCodeFixer.sequentiallyApplyFixes(fixedOutput, result.applyingMessages);
        var applyingMessages = [];
        // not applied fixing messages
        var remainingMessages = [];
        // original means original for applyingMessages and remainingMessages
        // pre-applyingMessages + remainingMessages
        var originalMessages = [];
        var fixerProcessList = ruleDescriptors.fixableDescriptors.map(function (ruleDescriptor) {
            return function (sourceText) {
                // create new SourceCode object
                var preProcessResult = preProcess(sourceText, sourceCode.filePath);
                var isPluginReturnAnAST = isTxtAST(preProcessResult);
                var textForAST = isPluginReturnAnAST ? sourceText : preProcessResult.text;
                var ast = isPluginReturnAnAST ? preProcessResult : preProcessResult.ast;
                var newSourceCode = new TextlintSourceCodeImpl({
                    text: textForAST,
                    ast: ast,
                    filePath: resultFilePath,
                    ext: sourceCode.ext
                });
                // create new Task
                var task = new FixerTask({
                    config: config,
                    fixableRuleDescriptor: ruleDescriptor,
                    filterRuleDescriptors: filterRules,
                    sourceCode: newSourceCode,
                    configBaseDir: configBaseDir
                });
                return TaskRunner.process(task).then(function (messages) {
                    var result = postProcess(messages, sourceCode.filePath);
                    var filteredResult = {
                        messages: _this.messageProcessManager.process(result.messages),
                        filePath: result.filePath ? result.filePath : "<Unkown" + sourceCode.ext + ">"
                    };
                    // TODO: should be removed resultFilePath
                    resultFilePath = filteredResult.filePath;
                    var applied = applyFixesToSourceCode(newSourceCode, filteredResult.messages);
                    // add messages
                    Array.prototype.push.apply(applyingMessages, applied.applyingMessages);
                    Array.prototype.push.apply(remainingMessages, applied.remainingMessages);
                    Array.prototype.push.apply(originalMessages, applied.messages);
                    // if not fixed, still use current sourceText
                    if (!applied.fixed) {
                        return sourceText;
                    }
                    // if fixed, use fixed text at next
                    return applied.output;
                });
            };
        });
        var promiseTask = fixerProcessList.reduce(function (promise, fixerProcess) {
            return promise.then(function (sourceText) {
                return fixerProcess(sourceText);
            });
        }, Promise.resolve(sourceCode.text));
        return promiseTask.then(function (output) {
            debug("Finish Processing: " + resultFilePath);
            debug("applyingMessages: " + applyingMessages.length);
            debug("remainingMessages: " + remainingMessages.length);
            return {
                filePath: resultFilePath ? resultFilePath : "<Unkown" + sourceCode.ext + ">",
                output: output,
                messages: originalMessages,
                applyingMessages: applyingMessages,
                remainingMessages: remainingMessages
            };
        });
    };
    return FixerProcessor;
}());
export default FixerProcessor;
//# sourceMappingURL=fixer-processor.js.map