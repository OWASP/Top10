"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __importDefault(require("assert"));
var feature_flag_1 = require("@textlint/feature-flag");
var SourceLocation = /** @class */ (function () {
    function SourceLocation(source) {
        this.source = source;
    }
    /**
     * adjust node's location with error's padding location.
     */
    SourceLocation.prototype.adjust = function (reportArgs) {
        var node = reportArgs.node, ruleError = reportArgs.ruleError, ruleId = reportArgs.ruleId;
        var errorPrefix = "[" + ruleId + "]" || "";
        var padding = ruleError;
        /*
         FIXME: It is old and un-document way
         new RuleError("message", index);
         */
        var _backwardCompatibleIndexValue;
        if (typeof padding === "number") {
            _backwardCompatibleIndexValue = padding;
            feature_flag_1.throwIfTesting(errorPrefix + " This is un-document way:\nreport(node, new RuleError(\"message\", index);\n\nPlease use { index }: \n\nreport(node, new RuleError(\"message\", {\n    index: paddingLineColumn\n});\n");
        }
        // when running from textlint-tester, assert
        if (padding.line === undefined && padding.column !== undefined) {
            // FIXME: Backward compatible <= textlint.5.5
            feature_flag_1.throwIfTesting(errorPrefix + " Have to use a sets with \"line\" and \"column\".\nSee FAQ: https://github.com/textlint/textlint/blob/master/docs/faq/line-column-or-index.md            \n\nreport(node, new RuleError(\"message\", {\n    line: paddingLineNumber,\n    column: paddingLineColumn\n});\n\nOR use \"index\" property insteadof only \"column\".\n\nreport(node, new RuleError(\"message\", {\n    index: paddingLineColumn\n});\n");
        }
        // When either one of {column, line} or {index} is not used, throw error
        if ((padding.line !== undefined || padding.column !== undefined) && padding.index !== undefined) {
            // Introduced textlint 5.6
            // https://github.com/textlint/textlint/releases/tag/5.6.0
            // Always throw Error
            throw new Error(errorPrefix + " Have to use one of {line, column} or {index}.\nYou should use either one:\n\nuse \"line\" and \"column\" property\n\nreport(node, new RuleError(\"message\", {\n    line: paddingLineNumber,\n    column: paddingLineColumn\n});\n\nOR \n\nuse \"index\" property\n\nreport(node, new RuleError(\"message\", {\n    index: paddingIndexValue\n});\n");
        }
        var adjustedLoc = this.toAbsoluteLocation(node, padding, _backwardCompatibleIndexValue);
        var adjustedFix = this.toAbsolutePositionFix(node, padding);
        /*
         {
         line,
         column
         fix?
         }
         */
        return Object.assign({}, adjustedLoc, adjustedFix);
    };
    SourceLocation.prototype.toAbsoluteLocation = function (node, padding, _paddingIndex) {
        var nodeRange = node.range;
        var line = node.loc.start.line;
        var column = node.loc.start.column;
        // when use {index}
        if (padding.index !== undefined || _paddingIndex !== undefined) {
            var startNodeIndex = nodeRange[0];
            var paddingIndex = _paddingIndex || padding.index;
            var position = this.source.indexToPosition(startNodeIndex + paddingIndex);
            return {
                column: position.column,
                line: position.line
            };
        }
        // when use {line, column}
        if (padding.line !== undefined && padding.column !== undefined) {
            if (padding.line > 0) {
                var addedLine = line + padding.line;
                // when report with padding {line, column}, message.column should be 0 + padding.column.
                // In other word, padding line > 0 and message.column start with 0.
                if (padding.column > 0) {
                    return {
                        line: addedLine,
                        column: padding.column
                    };
                }
                else {
                    return {
                        line: addedLine,
                        column: column
                    };
                }
            }
        }
        // when use { line } only
        if (padding.line !== undefined && padding.line > 0) {
            var addedLine = line + padding.line;
            return {
                line: addedLine,
                column: column
            };
        }
        // when use { column } only
        // FIXME: backward compatible @ un-document
        // Remove next version 6?
        /*
         new RuleError({
            column: index
         });
         */
        if (padding.column !== undefined && padding.column > 0) {
            var addedColumn = column + padding.column;
            return {
                line: line,
                column: addedColumn
            };
        }
        return {
            column: column,
            line: line
        };
    };
    /**
     * Adjust `fix` command range
     * if `fix.isAbsolute` is not absolute position, adjust the position from the `node`.
     */
    SourceLocation.prototype.toAbsolutePositionFix = function (node, ruleErrorObject) {
        var nodeRange = node.range;
        // if not found `fix`, return empty object
        if (ruleErrorObject.fix === undefined) {
            return {};
        }
        assert_1.default.ok(typeof ruleErrorObject.fix === "object", "fix should be FixCommand object");
        // if absolute position return self
        if (ruleErrorObject.fix.isAbsolute) {
            return {
                // remove other property that is not related `fix`
                // the return object will be merged by `Object.assign`
                fix: {
                    range: ruleErrorObject.fix.range,
                    text: ruleErrorObject.fix.text
                }
            };
        }
        // if relative position return adjusted position
        return {
            // fix(command) is relative from node's range
            fix: {
                range: [
                    nodeRange[0] + ruleErrorObject.fix.range[0],
                    nodeRange[0] + ruleErrorObject.fix.range[1]
                ],
                text: ruleErrorObject.fix.text
            }
        };
    };
    return SourceLocation;
}());
exports.default = SourceLocation;
//# sourceMappingURL=source-location.js.map