// LICENSE : MIT
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var TextlintRuleErrorImpl_1 = require("../context/TextlintRuleErrorImpl");
var promise_event_emitter_1 = require("./promise-event-emitter");
var source_location_1 = __importDefault(require("../core/source-location"));
var timing_1 = __importDefault(require("../util/timing"));
var MessageType_1 = __importDefault(require("../shared/type/MessageType"));
var events_1 = require("events");
var assert = __importStar(require("assert"));
var utils_1 = require("@textlint/utils");
var TextlintRuleContextImpl_1 = require("../context/TextlintRuleContextImpl");
var debug_1 = __importDefault(require("debug"));
var ast_traverse_1 = require("@textlint/ast-traverse");
var traverseController = new ast_traverse_1.Controller();
var debug = debug_1.default("textlint:core-task");
var RuleTypeEmitter = /** @class */ (function (_super) {
    __extends(RuleTypeEmitter, _super);
    function RuleTypeEmitter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return RuleTypeEmitter;
}(promise_event_emitter_1.PromiseEventEmitter));
/**
 * CoreTask receive AST and prepare, traverse AST, emit nodeType event!
 * You can observe task and receive "message" event that is TextLintMessage.
 */
var TextLintCoreTask = /** @class */ (function (_super) {
    __extends(TextLintCoreTask, _super);
    function TextLintCoreTask() {
        var _this = _super.call(this) || this;
        _this.ruleTypeEmitter = new RuleTypeEmitter();
        return _this;
    }
    Object.defineProperty(TextLintCoreTask, "events", {
        get: function () {
            return {
                // receive start event
                start: "start",
                // receive message from each rules
                message: "message",
                // receive complete event
                complete: "complete",
                // receive error event
                error: "error"
            };
        },
        enumerable: false,
        configurable: true
    });
    TextLintCoreTask.prototype.createShouldIgnore = function () {
        var _this = this;
        var shouldIgnore = function (args) {
            var ruleId = args.ruleId, range = args.range, optional = args.optional;
            assert.ok(typeof range[0] !== "undefined" && typeof range[1] !== "undefined" && range[0] >= 0 && range[1] >= 0, "ignoreRange should have actual range: " + range);
            // FIXME: should have index, loc
            // should be compatible with LintReportedMessage?
            var message = {
                type: MessageType_1.default.ignore,
                ruleId: ruleId,
                range: range,
                // ignoring target ruleId - default: filter all messages
                // This ruleId should be normalized, because the user can report any value
                ignoringRuleId: optional.ruleId ? utils_1.normalizeTextlintKeyPath(optional.ruleId) : "*"
            };
            _this.emit(TextLintCoreTask.events.message, message);
        };
        return shouldIgnore;
    };
    TextLintCoreTask.prototype.createReporter = function (sourceCode) {
        var _this = this;
        var sourceLocation = new source_location_1.default(sourceCode);
        /**
         * push new RuleError to results
         * @param {ReportMessage} reportArgs
         */
        var reportFunction = function (reportArgs) {
            var ruleId = reportArgs.ruleId, severity = reportArgs.severity, ruleError = reportArgs.ruleError;
            debug("%s pushReport %s", ruleId, ruleError);
            var _a = sourceLocation.adjust(reportArgs), line = _a.line, column = _a.column, fix = _a.fix;
            var index = sourceCode.positionToIndex({ line: line, column: column });
            // add TextLintMessage
            var message = {
                type: MessageType_1.default.lint,
                ruleId: ruleId,
                message: ruleError.message,
                index: index,
                // See https://github.com/textlint/textlint/blob/master/typing/textlint.d.ts
                line: line,
                column: column + 1,
                severity: severity,
                fix: fix !== undefined ? fix : undefined
            };
            if (!(ruleError instanceof TextlintRuleErrorImpl_1.TextlintRuleErrorImpl)) {
                // FIXME: RuleReportedObject should be removed
                // `error` is a any data.
                var data = ruleError;
                message.data = data;
            }
            _this.emit(TextLintCoreTask.events.message, message);
        };
        return reportFunction;
    };
    /**
     * start process and emitting events.
     * You can listen message by `task.on("message", message => {})`
     * @param {SourceCode} sourceCode
     */
    TextLintCoreTask.prototype.startTraverser = function (sourceCode) {
        var _this = this;
        this.emit(TextLintCoreTask.events.start);
        var promiseQueue = [];
        var ruleTypeEmitter = this.ruleTypeEmitter;
        traverseController.traverse(sourceCode.ast, {
            enter: function (node, parent) {
                var type = node.type;
                Object.defineProperty(node, "parent", { value: parent });
                if (ruleTypeEmitter.listenerCount(type) > 0) {
                    var promise = ruleTypeEmitter.emit(type, node);
                    promiseQueue.push(promise);
                }
            },
            leave: function (node) {
                var type = node.type + ":exit";
                if (ruleTypeEmitter.listenerCount(type) > 0) {
                    var promise = ruleTypeEmitter.emit(type, node);
                    promiseQueue.push(promise);
                }
            }
        });
        Promise.all(promiseQueue)
            .then(function () {
            _this.emit(TextLintCoreTask.events.complete);
        })
            .catch(function (error) {
            _this.emit(TextLintCoreTask.events.error, error);
        });
    };
    /**
     * try to get rule object
     */
    TextLintCoreTask.prototype.tryToGetRuleObject = function (ruleCreator, ruleContext, ruleOptions) {
        try {
            return ruleCreator(ruleContext, ruleOptions);
        }
        catch (error) {
            error.message = "Error while loading rule '" + ruleContext.id + "': " + error.message;
            throw error;
        }
    };
    /**
     * try to get filter rule object
     */
    TextLintCoreTask.prototype.tryToGetFilterRuleObject = function (ruleCreator, ruleContext, ruleOptions) {
        try {
            return ruleCreator(ruleContext, ruleOptions);
        }
        catch (error) {
            error.message = "Error while loading filter rule '" + ruleContext.id + "': " + error.message;
            throw error;
        }
    };
    /**
     * add all the node types as listeners of the rule
     * @param {Function} ruleCreator
     * @param {Readonly<RuleContext>|Readonly<FilterRuleContext>} ruleContext
     * @param {Object|boolean|undefined} ruleOptions
     * @returns {Object}
     */
    TextLintCoreTask.prototype.tryToAddListenRule = function (ruleCreator, ruleContext, ruleOptions) {
        var _this = this;
        var ruleObject = ruleContext instanceof TextlintRuleContextImpl_1.TextlintRuleContextImpl
            ? this.tryToGetRuleObject(ruleCreator, ruleContext, ruleOptions)
            : this.tryToGetFilterRuleObject(ruleCreator, ruleContext, ruleOptions);
        var types = Object.keys(ruleObject);
        types.forEach(function (nodeType) {
            _this.ruleTypeEmitter.on(nodeType, timing_1.default.enabled ? timing_1.default.time(ruleContext.id, ruleObject[nodeType]) : ruleObject[nodeType]);
        });
    };
    return TextLintCoreTask;
}(events_1.EventEmitter));
exports.default = TextLintCoreTask;
//# sourceMappingURL=textlint-core-task.js.map