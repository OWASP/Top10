// LICENSE : MIT
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parse = exports.Syntax = void 0;
var markdown_syntax_map_1 = require("./mapping/markdown-syntax-map");
var ast_node_types_1 = require("@textlint/ast-node-types");
Object.defineProperty(exports, "Syntax", { enumerable: true, get: function () { return ast_node_types_1.ASTNodeTypes; } });
var traverse_1 = __importDefault(require("traverse"));
var structured_source_1 = __importDefault(require("structured-source"));
var debug_1 = __importDefault(require("debug"));
// @ts-ignore
var unified_1 = __importDefault(require("unified"));
// @ts-ignore
var remark_parse_1 = __importDefault(require("remark-parse"));
// @ts-ignore
var remark_frontmatter_1 = __importDefault(require("remark-frontmatter"));
var debug = debug_1.default("@textlint/markdown-to-ast");
var remark = unified_1.default().use(remark_parse_1.default).use(remark_frontmatter_1.default, ["yaml"]);
/**
 * parse markdown text and return ast mapped location info.
 * @param {string} text
 * @returns {TxtNode}
 */
function parse(text) {
    var ast = remark.parse(text);
    var src = new structured_source_1.default(text);
    traverse_1.default(ast).forEach(function (node) {
        // eslint-disable-next-line no-invalid-this
        if (this.notLeaf) {
            if (node.type) {
                var replacedType = markdown_syntax_map_1.SyntaxMap[node.type];
                if (!replacedType) {
                    debug("replacedType : " + replacedType + " , node.type: " + node.type);
                }
                else {
                    node.type = replacedType;
                }
            }
            // map `range`, `loc` and `raw` to node
            if (node.position) {
                var position = node.position;
                var positionCompensated = {
                    start: { line: position.start.line, column: Math.max(position.start.column - 1, 0) },
                    end: { line: position.end.line, column: Math.max(position.end.column - 1, 0) }
                };
                var range = src.locationToRange(positionCompensated);
                node.loc = positionCompensated;
                node.range = range;
                node.raw = text.slice(range[0], range[1]);
                // Compatible for https://github.com/wooorm/unist, but hidden
                Object.defineProperty(node, "position", {
                    enumerable: false,
                    configurable: false,
                    writable: false,
                    value: position
                });
            }
        }
    });
    return ast;
}
exports.parse = parse;
//# sourceMappingURL=index.js.map