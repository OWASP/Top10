// LICENSE : MIT
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VisitorOption = exports.traverse = exports.Controller = exports.TxtElement = void 0;
/**
 * is TxtNode?
 */
function isNode(node) {
    if (node == null) {
        return false;
    }
    return typeof node === "object" && (typeof node.type === "string" || typeof node.t === "string");
}
var TxtElement = /** @class */ (function () {
    function TxtElement(node) {
        this.node = node;
    }
    return TxtElement;
}());
exports.TxtElement = TxtElement;
var BREAK = {};
var SKIP = {};
var VisitorOption = {
    Break: BREAK,
    Skip: SKIP
};
exports.VisitorOption = VisitorOption;
var Controller = /** @class */ (function () {
    function Controller() {
    }
    Controller.prototype.__willStartTraverse = function () {
        this.__current = null;
        this.__worklist = [];
        this.__leavelist = [];
    };
    Controller.prototype.__execute = function (callback, element) {
        var result = undefined;
        var previous = this.__current;
        this.__current = element;
        if (callback) {
            var parentNode = this.__leavelist[this.__leavelist.length - 1].node;
            // ignore null element
            if (!element.node) {
                return;
            }
            result = callback.call(this, element.node, parentNode);
        }
        this.__current = previous;
        return result;
    };
    /**
     * Gets parent nodes of current node.
     * The parent nodes are returned in order from the closest parent to the outer ones.
     * Current node is {@link current}.
     * @returns {Array}
     * @public
     */
    Controller.prototype.parents = function () {
        var i, iz;
        // first node is sentinel
        var result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            var txtElement = this.__leavelist[i];
            var node = txtElement.node;
            if (node) {
                result.push(node);
            }
        }
        return result;
    };
    /**
     * Gets current node during traverse.
     * @returns {TxtNode|null}
     * @public
     */
    Controller.prototype.current = function () {
        if (!this.__current) {
            return null;
        }
        return this.__current.node;
    };
    /**
     * Traverse AST with visitor
     * @param {TxtParentNode} root
     * @param {Visitor} visitor
     */
    Controller.prototype.traverse = function (root, visitor) {
        // Note: This is based https://github.com/estools/estraverse
        // Avoid recursive call by design
        var ret;
        this.__willStartTraverse();
        // Stop object
        var sentinel = new TxtElement(null);
        // reference
        var worklist = this.__worklist;
        var leavelist = this.__leavelist;
        // initialize
        worklist.push(new TxtElement(root));
        leavelist.push(new TxtElement(null));
        while (worklist.length) {
            var element = worklist.pop();
            if (element === undefined) {
                continue;
            }
            if (element === sentinel) {
                element = leavelist.pop();
                if (element === undefined) {
                    continue;
                }
                ret = this.__execute(visitor.leave, element);
                if (ret === BREAK) {
                    return;
                }
                continue;
            }
            if (element.node) {
                ret = this.__execute(visitor.enter, element);
                if (ret === BREAK) {
                    return;
                }
                worklist.push(sentinel);
                leavelist.push(element);
                if (ret === SKIP) {
                    continue;
                }
                var node = element.node;
                var candidates = Object.keys(node);
                var current = candidates.length;
                while ((current -= 1) >= 0) {
                    var key = candidates[current];
                    var candidate = node[key];
                    if (!candidate) {
                        continue;
                    }
                    if (Array.isArray(candidate)) {
                        var current2 = candidate.length;
                        while ((current2 -= 1) >= 0) {
                            if (!candidate[current2]) {
                                continue;
                            }
                            if (isNode(candidate[current2])) {
                                element = new TxtElement(candidate[current2]);
                            }
                            else {
                                continue;
                            }
                            if (element) {
                                worklist.push(element);
                            }
                        }
                    }
                    else if (isNode(candidate)) {
                        worklist.push(new TxtElement(candidate));
                    }
                }
            }
        }
    };
    return Controller;
}());
exports.Controller = Controller;
function traverse(root, visitor) {
    var controller = new Controller();
    return controller.traverse(root, visitor);
}
exports.traverse = traverse;
//# sourceMappingURL=index.js.map